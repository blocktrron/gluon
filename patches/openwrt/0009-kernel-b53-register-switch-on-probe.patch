From: David Bauer <mail@david-bauer.net>
Date: Sun, 21 Oct 2018 20:56:07 +0200
Subject: kernel: b53: register switch on probe

Currently, the b53 MDIO switch driver registers the switch on
config-init and not on device probe. Because of this, the switch
gets added every time the associated interface comes up.

This commit fixes this behavior by registering the switch on device
probe.

Compile- and run-tested on OCEDO Koala.

Signed-off-by: David Bauer <mail@david-bauer.net>

diff --git a/target/linux/generic/files/drivers/net/phy/b53/b53_mdio.c b/target/linux/generic/files/drivers/net/phy/b53/b53_mdio.c
index 75bb4d941c42d435d7c41a6d3531a0b018aa010c..5934befc9e0c93c4fb97efe2a49c0d339df9ca2e 100644
--- a/target/linux/generic/files/drivers/net/phy/b53/b53_mdio.c
+++ b/target/linux/generic/files/drivers/net/phy/b53/b53_mdio.c
@@ -273,55 +273,54 @@ static struct b53_io_ops b53_mdio_ops = {
 
 static int b53_phy_probe(struct phy_device *phydev)
 {
-	struct b53_device dev;
+	struct b53_device *dev;
 	int ret;
 
 	/* allow the generic phy driver to take over */
 	if (phydev->mdio.addr != B53_PSEUDO_PHY && phydev->mdio.addr != 0)
 		return -ENODEV;
 
-	dev.current_page = 0xff;
-	dev.priv = phydev->mdio.bus;
-	dev.ops = &b53_mdio_ops;
-	dev.pdata = NULL;
-	mutex_init(&dev.reg_mutex);
+	dev = b53_switch_alloc(&phydev->mdio.dev, &b53_mdio_ops, phydev->mdio.bus);
+	if (!dev)
+		return -ENOMEM;
 
-	ret = b53_switch_detect(&dev);
+	dev->current_page = 0xff;
+	dev->priv = phydev->mdio.bus;
+	dev->ops = &b53_mdio_ops;
+	dev->pdata = NULL;
+	mutex_init(&dev->reg_mutex);
+
+	ret = b53_switch_detect(dev);
 	if (ret)
 		return ret;
 
-	if (is5325(&dev) || is5365(&dev))
+	if (is5325(dev) || is5365(dev))
 		phydev->supported = SUPPORTED_100baseT_Full;
 	else
 		phydev->supported = SUPPORTED_1000baseT_Full;
 
 	phydev->advertising = phydev->supported;
 
+	ret = b53_switch_register(dev);
+	if (ret) {
+		dev_err(dev->dev, "failed to register switch: %i\n", ret);
+		return ret;
+	}
+
+	phydev->priv = dev;
+
 	return 0;
 }
 
 static int b53_phy_config_init(struct phy_device *phydev)
 {
-	struct b53_device *dev;
-	int ret;
-
-	dev = b53_switch_alloc(&phydev->mdio.dev, &b53_mdio_ops, phydev->mdio.bus);
-	if (!dev)
-		return -ENOMEM;
+	struct b53_device *dev = phydev->priv;
 
 	/* we don't use page 0xff, so force a page set */
 	dev->current_page = 0xff;
 	/* force the ethX as alias */
 	dev->sw_dev.alias = phydev->attached_dev->name;
 
-	ret = b53_switch_register(dev);
-	if (ret) {
-		dev_err(dev->dev, "failed to register switch: %i\n", ret);
-		return ret;
-	}
-
-	phydev->priv = dev;
-
 	return 0;
 }
 
